from typing import Final
import sqlite3
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackContext
import schedule
import time
import json
from datetime import datetime

TOKEN = '6858171735:AAEALynfPgnsrvC3QB1an8fqVEiy342_Np4'
BOT_USERNAME: Final = '@thisisyourdailyreminder_bot'
my_chat_id = 1242746236


# Connect to SQLite database
conn = sqlite3.connect('feelings.db')
cursor = conn.cursor()
cursor.execute("CREATE TABLE IF NOT EXISTS command_logs (command TEXT, timestamp TEXT)")

# Load commands from JSON file
with open('telegrambot\singleorders.json') as f:
    commands_data = json.load(f)

# Only respond to messages from my chat_id
def echo(update: Update, context: CallbackContext) -> None:
    if update.message.chat_id == my_chat_id:
        update.message.reply_text(update.message.text)
        
# commands
async def start_command(update: Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Hello! How do you feel today?")
    # Define message handler to store the feeling in the database

async def help_command(update: Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('How may I help you ?')
    

async def custom_command(update: Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('This is a custom command.')
    
# async def store_feeling(update: Update, context: CallbackContext) -> None:
#     user_id = update.message.from_user.id
#     feeling_text = update.message.text

#     # Insert data into the database
#     cursor.execute("CREATE TABLE IF NOT EXISTS feelings (user_id TEXT, feeling_text TEXT)")
#     cursor.execute("INSERT INTO feelings (user_id, feeling_text) VALUES (?, ?)", (user_id, feeling_text))
#     conn.commit()

#     await update.message.reply_text('Your feeling has been stored successfully!')

async def handle_single_command(update: Update, context:CallbackContext):
    # variables
    message = update.message.text
    command = message.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

# Check if the command exists in the JSON data
    for cmd in commands_data['single_orders']['simple']['commands']:
        if cmd['key'] == command:
            # Reply with the corresponding message
            # context.bot.send_message(chat_id=update.effective_chat.id, text=cmd['reply'])
            await update.message.reply_text(text=cmd['reply'])
            
            # Log the command in the database
            cursor.execute("INSERT INTO command_logs (command, timestamp) VALUES (?, ?)", (command, current_time))
            conn.commit()
            break

# Example usage of the handler
# You should add this handler to your bot's dispatcher
# updater.dispatcher.add_handler(MessageHandler(Filters.command, handle_single_command))

# Don't forget to close the connection when your bot shuts down
# conn.close()


#  Responses

def handle_response(text:str) -> str:
    processed: str = text.lower()
    if 'hello' in processed: 
        return 'Hi there!'
    if 'how are you' in processed:
        return 'I am good thank you! What about you ?'
    if 'fine' in processed: 
        return 'Good to hear!'
    if 'bye' in processed:
        return 'Bye bye, see you soon'
    
    return 'I am sorry, I do not understand.'

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_type: str = update.message.chat.type
    text: str = update.message.text

    print(f'User ({update.message.chat.id}) in {message_type}: "{text}"')

    if message_type == 'group':
        if BOT_USERNAME in text:
            new_text: str = text.replace(BOT_USERNAME, '').strip()
            response: str = handle_response(new_text)
        else:
            return
    else:
        response: str = handle_response(text)
    

    print('Bot', response)
    await update.message.reply_text(response)

async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f'Update {update} caused error {context.error}')

# async def send_daily_message():
#     bot = Bot(TOKEN)
#     await bot.send_message(chat_id=my_chat_id, text="Hello A, how are you?")

if __name__ == '__main__':
    print('Starting bot...')
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler('start', start_command))
    app.add_handler(CommandHandler('help', help_command))
    app.add_handler(CommandHandler('custom', custom_command))
    # app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, store_feeling))
    app.add_handler(MessageHandler(filters.COMMAND, handle_single_command))


    # Messages
    app.add_handler(MessageHandler(filters.TEXT, handle_message))

    # Errors
    app.add_error_handler(error)

     # Schedule the daily message
    # schedule.every().day.at("11:36").do(send_daily_message)

    #Polls the bot
    print('Polling...')
    app.run_polling(poll_interval=3)



# HANDLE COMPLEX COMMANDS
async def complex_command(update: Update, context:CallbackContext):
    # variables
    message = update.message.text
    command = message.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Check if the command exists in the JSON data
    for cmd in commands_data['single_orders']['complex']['commands']:
        if cmd['key'] == command:
            # Reply with the corresponding message
            await update.message.reply_text(text=cmd['follow_up_question'])
            follow_up_question = cmd.get('follow_up_question')
            if follow_up_question:
                buttons = [[value for value in cmd['buttons'].values()]]
                custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                await update.message.reply_text(follow_up_question, reply_markup=custom_markup)


                # Retrieve user's reply and add to database
                user_response = update.message.text
                cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (?, ?, ?)",
                               (command, current_time, user_response))
                conn.commit()

                await update.message.reply_text(text=cmd['reply'])
                break
