conn = psycopg2.connect(
    dbname=os.getenv('PG_DBNAME'),
    user=os.getenv('PG_USER'),
    password=os.getenv('PG_PASSWORD'),
    host=os.getenv('PG_HOST'),
    port=os.getenv('PG_PORT')
)
cursor = conn.cursor()
# Connect to SQLite database TO REPLACE !!!
conn = sqlite3.connect('feelings.db')
cursor = conn.cursor()
cursor.execute("CREATE TABLE IF NOT EXISTS command_logs (command TEXT, timestamp TEXT, reason TEXT)")


from typing import Final
import sqlite3
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackContext
import schedule
import time
import json
from datetime import datetime

TOKEN = '6858171735:AAEALynfPgnsrvC3QB1an8fqVEiy342_Np4'
BOT_USERNAME: Final = '@thisisyourdailyreminder_bot'
my_chat_id = 1242746236


# Connect to SQLite database
conn = sqlite3.connect('feelings.db')
cursor = conn.cursor()
cursor.execute("CREATE TABLE IF NOT EXISTS command_logs (command TEXT, timestamp TEXT)")

# Load commands from JSON file
with open('telegrambot\singleorders.json') as f:
    commands_data = json.load(f)

# Only respond to messages from my chat_id
def echo(update: Update, context: CallbackContext) -> None:
    if update.message.chat_id == my_chat_id:
        update.message.reply_text(update.message.text)
        
# commands
async def start_command(update: Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Hello! How do you feel today?")
    # Define message handler to store the feeling in the database

async def help_command(update: Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('How may I help you ?')
    

async def custom_command(update: Update, context:ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('This is a custom command.')
    
# async def store_feeling(update: Update, context: CallbackContext) -> None:
#     user_id = update.message.from_user.id
#     feeling_text = update.message.text

#     # Insert data into the database
#     cursor.execute("CREATE TABLE IF NOT EXISTS feelings (user_id TEXT, feeling_text TEXT)")
#     cursor.execute("INSERT INTO feelings (user_id, feeling_text) VALUES (?, ?)", (user_id, feeling_text))
#     conn.commit()

#     await update.message.reply_text('Your feeling has been stored successfully!')

async def handle_single_command(update: Update, context:CallbackContext):
    # variables
    message = update.message.text
    command = message.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

# Check if the command exists in the JSON data
    for cmd in commands_data['single_orders']['simple']['commands']:
        if cmd['key'] == command:
            # Reply with the corresponding message
            # context.bot.send_message(chat_id=update.effective_chat.id, text=cmd['reply'])
            await update.message.reply_text(text=cmd['reply'])
            
            # Log the command in the database
            cursor.execute("INSERT INTO command_logs (command, timestamp) VALUES (?, ?)", (command, current_time))
            conn.commit()
            break

# Example usage of the handler
# You should add this handler to your bot's dispatcher
# updater.dispatcher.add_handler(MessageHandler(Filters.command, handle_single_command))

# Don't forget to close the connection when your bot shuts down
# conn.close()


#  Responses

def handle_response(text:str) -> str:
    processed: str = text.lower()
    if 'hello' in processed: 
        return 'Hi there!'
    if 'how are you' in processed:
        return 'I am good thank you! What about you ?'
    if 'fine' in processed: 
        return 'Good to hear!'
    if 'bye' in processed:
        return 'Bye bye, see you soon'
    
    return 'I am sorry, I do not understand.'

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_type: str = update.message.chat.type
    text: str = update.message.text

    print(f'User ({update.message.chat.id}) in {message_type}: "{text}"')

    if message_type == 'group':
        if BOT_USERNAME in text:
            new_text: str = text.replace(BOT_USERNAME, '').strip()
            response: str = handle_response(new_text)
        else:
            return
    else:
        response: str = handle_response(text)
    

    print('Bot', response)
    await update.message.reply_text(response)

async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f'Update {update} caused error {context.error}')

# async def send_daily_message():
#     bot = Bot(TOKEN)
#     await bot.send_message(chat_id=my_chat_id, text="Hello A, how are you?")

if __name__ == '__main__':
    print('Starting bot...')
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler('start', start_command))
    app.add_handler(CommandHandler('help', help_command))
    app.add_handler(CommandHandler('custom', custom_command))
    # app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, store_feeling))
    app.add_handler(MessageHandler(filters.COMMAND, handle_single_command))


    # Messages
    app.add_handler(MessageHandler(filters.TEXT, handle_message))

    # Errors
    app.add_error_handler(error)

     # Schedule the daily message
    # schedule.every().day.at("11:36").do(send_daily_message)

    #Polls the bot
    print('Polling...')
    app.run_polling(poll_interval=3)



# HANDLE COMPLEX COMMANDS
async def complex_command(update: Update, context:CallbackContext):
    # variables
    message = update.message.text
    command = message.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Check if the command exists in the JSON data
    for cmd in commands_data['single_orders']['complex']['commands']:
        if cmd['key'] == command:
            # Reply with the corresponding message
            await update.message.reply_text(text=cmd['follow_up_question'])
            follow_up_question = cmd.get('follow_up_question')
            if follow_up_question:
                buttons = [[value for value in cmd['buttons'].values()]]
                custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                await update.message.reply_text(follow_up_question, reply_markup=custom_markup)


                # Retrieve user's reply and add to database
                user_response = update.message.text
                cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (?, ?, ?)",
                               (command, current_time, user_response))
                conn.commit()

                await update.message.reply_text(text=cmd['reply'])
                break


21/03:
import os
from typing import Final
from telegram import ReplyKeyboardMarkup
import psycopg2
from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackContext
import json
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()
# Private infos
TOKEN = os.getenv('TOKEN')
BOT_USERNAME: Final = os.getenv('Bot')
my_chat_id = os.getenv('my_chat_id')

# Connection to database
conn = psycopg2.connect(
    dbname=os.getenv('PG_DBNAME'),
    user=os.getenv('PG_USER'),
    password=os.getenv('PG_PASSWORD'),
    host=os.getenv('PG_HOST'),
    port=os.getenv('PG_PORT')
)
cursor = conn.cursor()

# Load commands from JSON file
with open('telegrambot/singleorders.json') as f:
    commands_data = json.load(f)

# Only respond to messages from my chat_id
def echo(update: Update, context: CallbackContext) -> None:
    if update.message.chat_id == my_chat_id:
        update.message.reply_text(update.message.text)    

# HANDLE COMMANDS
async def handle_commands(update: Update, context:CallbackContext):
    # variables
    message = update.message.text
    command = message.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Check if the command exists in the JSON data
    for cmd in commands_data['single_orders']['simple']['commands']:
        if cmd['key'] == command:
            # Reply with the corresponding message
            await update.message.reply_text(text=cmd['reply'])
            
            # Log the command in the database
            cursor.execute("INSERT INTO command_logs (command, timestamp) VALUES (%s, %s)", (command, current_time))
            conn.commit()
            return
        
    # for cmd in commands_data['single_orders']['complex']['commands']:
    #     if cmd['key'] == command:
    #         context.user_data['command'] = command
    #         context.user_data['timestamp'] = current_time
    #         # Reply with the corresponding message
    #         follow_up_question = cmd.get('follow_up_question')
    #         if follow_up_question:
    #             buttons = [[value for value in cmd['buttons'].values()]]
    #             custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
    #             await update.message.reply_text(follow_up_question, reply_markup=custom_markup)


    #             # Retrieve user's reply and add to database
    #             user_response =  context.user_data.get('response')
    #             cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (?, ?, ?)",
    #                            (command, current_time, user_response))
    #             conn.commit()

    #         return
        
    await update.message.reply_text("Sorry, I couldn't find that command.") 

# async def handle_complex_response(update: Update, context: CallbackContext):
#     # Retrieve the user's response
#     user_response = update.message.text
    
#     # Retrieve command and timestamp from the context
#     command = context.user_data.get('command')
#     timestamp = context.user_data.get('timestamp')
        
#     # Retrieve the follow-up replies from the JSON data
#     follow_up_replies = None
#     for cmd in commands_data['single_orders']['complex']['commands']:
#         if cmd['key'] == command:
#             follow_up_replies = cmd.get('follow_up_replies')
#             break
#         # If follow-up replies are found and the user's response is valid, send the corresponding follow-up reply
#         if follow_up_replies and user_response in follow_up_replies:
#             follow_up_reply = follow_up_replies[user_response]
#             await update.message.reply_text(follow_up_reply)

#     # Store the user's response in the database
#         cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (?, ?, ?)",
#                        (command, timestamp, user_response))
#         conn.commit()
        
#         # Optionally, you can provide a reply acknowledging the user's response
#         await update.message.reply_text("Your response has been recorded.")
#     else:
#         await update.message.reply_text("Sorry, I couldn't process your response.")

async def handle_complex_response(update: Update, context: CallbackContext):
    # Retrieve the user's response
    user_response = update.message.text
    
    # Retrieve command and timestamp from the context
    command = context.user_data.get('command')
    timestamp = context.user_data.get('timestamp')
        
    # Retrieve the follow-up replies from the JSON data
    follow_up_replies = None
    for cmd in commands_data['single_orders']['complex']['commands']:
        if cmd['key'] == command:
            follow_up_replies = cmd.get('follow_up_replies')
            break
    
    # If follow-up replies are found and the user's response is valid, send the corresponding follow-up reply
    if follow_up_replies and user_response in follow_up_replies:
        follow_up_reply = follow_up_replies[user_response]
        await update.message.reply_text(follow_up_reply)

        # Store the user's response and reason in the database
        reason = follow_up_replies[user_response]
        cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (%s, %s, %s)",
                       (command, timestamp, reason))
        conn.commit()

        
        # Optionally, you can provide a reply acknowledging the user's response
        await update.message.reply_text("Your response has been recorded.")
    else:
        await update.message.reply_text("Sorry, I couldn't process your response.")

#  Handle unknown messages:
def handle_response(text:str) -> str:
    return 'I am sorry, I do not understand.'
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_type: str = update.message.chat.type
    text: str = update.message.text

    print(f'User ({update.message.chat.id}) in {message_type}: "{text}"')

    if message_type == 'group':
        if BOT_USERNAME in text:
            new_text: str = text.replace(BOT_USERNAME, '').strip()
            response: str = handle_response(new_text)
        else:
            return
    else:
        response: str = handle_response(text)
    

    print('Bot', response)
    await update.message.reply_text(response)
async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f'Update {update} caused error {context.error}')

if __name__ == '__main__':
    print('Starting bot...')
    app = Application.builder().token(TOKEN).build()

    # Commands
    app.add_handler(MessageHandler(filters.COMMAND, handle_commands))
    # app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_complex_response))
    # Messages
    app.add_handler(MessageHandler(filters.TEXT, handle_message))
    # Errors
    app.add_error_handler(error)

    #Polls the bot
    print('Polling...')
    app.run_polling(poll_interval=3)



Amy's attempt at handle complex command

for key in commands_data['single_orders']['complex'].items():
    for cmd in commands_data['single_orders']['complex']['commands']:
        key = cmd['key']
        context.user_data['command'] = user_command
        context.user_data['timestamp'] = current_time
        # Reply with the corresponding message
        follow_up_question = cmd.get('follow_up_question')
        if follow_up_question:
            buttons = [[value for value in cmd['buttons'].values()]]
            custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
            await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

            # Retrieve user's reply and add to database
            user_response =  context.user_data.get('response')
            cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (?, ?, ?)",
                           (user_command, current_time, user_response))
            conn.commit()

        return




async def handle_no_rebound_commands(update: Update, context:CallbackContext):
    # variables
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    for key in commands_data['single_orders']['complex']['no_rebound'].items():
        for cmd in commands_data['single_orders']['complex']['commands']['no_rebound']:
            key = cmd['key']
            if key == user_command:
                follow_up_question = cmd.get('follow_up_question')
                if follow_up_question:
                    buttons = [[value for value in cmd['buttons'].values()]]
                    custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                    await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                    user_response = update.message.text

                    for key,value in cmd['buttons'].items():
                        if user_response == value:
                            button_number = key
                            follow_up_replies = cmd.get('follow_up_replies', {})
                            bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

                            await update.message.reply_text(bot_reply)

                        # Retrieve user's reply and add to database
                        user_response =  context.user_data.get('response')
                        cursor.execute("INSERT INTO command_logs (command, timestamp, additional_infos) VALUES (?, ?, ?)",
                                (user_command, current_time, user_response))
                        conn.commit()

            return
        
    await update.message.reply_text("Sorry, I couldn't find that command.")
async def handle_opt_rebound_commands(update: Update, context:CallbackContext):
async def handle_comp_rebound_commands(update: Update, context:CallbackContext):


22/03 version
async def handle_complex_commands(update: Update, context:CallbackContext):
    # variables
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    for key in commands_data['single_orders']['complex'].items():
        for cmd in commands_data['single_orders']['complex']['commands']:
            key = cmd['key']
            if key == user_command:
                follow_up_question = cmd.get('follow_up_question')
                if follow_up_question:
                    buttons = [[value for value in cmd['buttons'].values()]]
                    custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                    await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                    user_response = update.message.text

                    for key,value in cmd['buttons'].items():
                        if user_response == value:
                            button_number = key
                            follow_up_replies = cmd.get('follow_up_replies', {})
                            bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

                            await update.message.reply_text(bot_reply)

                        # Retrieve user's reply and add to database
                        user_response =  context.user_data.get('response')
                        cursor.execute("INSERT INTO command_logs (command, timestamp, reason) VALUES (?, ?, ?)",
                                (user_command, current_time, user_response))
                        conn.commit()

            return
        
    await update.message.reply_text("Sorry, I couldn't find that command.") ***




    async def handle_complex_commands(update: Update, context:CallbackContext):
    for command_group in commands_data['single_orders']['complex'].values():
        for command_data in command_group:
            for command_info in command_data['commands']:
                key_complex = command_info['key']
            print(f"Executing SQL statement: {key_complex}")
            create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_complex} (timestamp TEXT, command TEXT, reason TEXT, details TEXT)"
            cursor.execute(create_complex_table)
            

    # variables
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    if key in commands_data['single_orders']['complex'].items():
        for cmd in commands_data['single_orders']['complex']['commands']['no_rebound']:
            key = cmd['key']
            if key == user_command:
                follow_up_question = cmd.get('follow_up_question')
                if follow_up_question:
                    buttons = [[value for value in cmd['buttons'].values()]]
                    custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                    await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                    user_response = update.message.text

                    for key,value in cmd['buttons'].items():
                        if user_response == value:
                            button_number = key
                            follow_up_replies = cmd.get('follow_up_replies', {})
                            bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

                            await update.message.reply_text(bot_reply)

                        # Retrieve user's reply and add to database
                        user_response =  context.user_data.get('response')
                        cursor.execute("INSERT INTO command_logs (timestamp, command, additional_infos) VALUES (?, ?, ?)",
                                (current_time, user_command, user_response))
                        conn.commit()
    
    if key in commands_data['single_orders']['complex']['optional_rebound']:
        for cmd in commands_data['single_orders']['complex']['commands']['optional_rebound']:
            key = cmd['key']
            if key == user_command:
                follow_up_question = cmd.get('follow_up_question') #Ask reason
                if follow_up_question:
                    buttons = [[value for value in cmd['buttons'].values()]]
                    custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                    await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                    user_response = update.message.text

                    for key,value in cmd['buttons'].items():
                        if user_response == value:
                            if key == '0':
                                button_number0 = key
                                follow_up_replies = cmd.get('follow_up_replies', {})
                                bot_reply0 = follow_up_replies.get(button_number0, "Sorry, I couldn't process your response.")
                                await update.message.reply_text(bot_reply0)

                                user_rebound_reply = update.message.text

                                if user_rebound_reply:
                                    bot_final_reply = cmd.get(text=cmd['reply'])
                                await update.message.reply_text(bot_final_reply)

                                user_response =  context.user_data.get('response')
                            cursor.execute("INSERT INTO command_logs (timestamp, command, reason, additional_infos) VALUES (?, ?, ?)",
                                (current_time, user_command, user_response, user_rebound_reply))
                            conn.commit()

                        else:
                            button_number = key
                            follow_up_replies = cmd.get('follow_up_replies', {})
                            bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

                            await update.message.reply_text(bot_reply)

                            # Retrieve user's reply and add to database
                            user_response =  context.user_data.get('response')
                            cursor.execute("INSERT INTO command_logs (timestamp, command, reason) VALUES (?, ?, ?)",
                                (current_time, user_command, user_response))
                            conn.commit()
        
    await update.message.reply_text("trololol.") 


    # Check if the user's command corresponds to a key from optional-rebound commands
for command_group in commands_data['single_orders']['complex'].values():
    for command_data in command_group:
        for command_info in command_data['commands']:
            key_complex = command_info['key']

            if user_command == key_complex:
                if key_complex in commands_data['single_orders']['complex']['no_rebound']:
                    # Your logic for no-rebound commands here
                    pass
                elif key_complex in commands_data['single_orders']['complex']['optional_rebound']:
                    # Your logic for optional-rebound commands here
                    pass
                else:
                    # Handle the case where the command is not found
                    await update.message.reply_text("Sorry, I couldn't find that command.")




    # Check if the command exists in the JSON data
    for command_group in commands_data['single_orders']['complex'].values():
        for command_data in command_group:
            for command_info in command_data['commands']:
                key_complex = command_info['key']

                # Check if the user's command corresponds to a key from no-rebound commands
                if key_complex in commands_data['single_orders']['complex']['no_rebound']:
                    for cmd in commands_data['single_orders']['complex']['no_rebound']:
                        if cmd['key'] == user_command:
                            follow_up_question = cmd.get('follow_up_question')
                            if follow_up_question:
                                buttons = [[value for value in cmd['buttons'].values()]]
                                custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                                await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                                user_response = update.message.text

                                for key, value in cmd['buttons'].items():
                                    if user_response == value:
                                        button_number = key
                                        follow_up_replies = cmd.get('follow_up_replies', {})
                                        bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

                                        await update.message.reply_text(bot_reply)

                                    # Retrieve user's reply and add to database
                                    user_response = context.user_data.get('response')
                                    cursor.execute("INSERT INTO command_logs (timestamp, command, additional_infos) VALUES (?, ?, ?)",
                                                   (current_time, user_command, user_response))
                                    conn.commit()

                # Check if the user's command corresponds to a key from optional-rebound commands
                if key_complex in commands_data['single_orders']['complex']['optional_rebound']:
                    for command_group in commands_data['single_orders']['complex'].values():
                        for command_data in command_group:
                            for command_info in command_data['commands']:
                                key_complex = command_info['key']

                                for cmd in commands_data['single_orders']['complex']['optional_rebound']:
                                    if cmd['key'] == user_command:
                                        follow_up_question = cmd.get('follow_up_question')  # Ask reason
                                        if follow_up_question:
                                            buttons = [[value for value in cmd['buttons'].values()]]
                                            custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                                            await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                                            user_response = update.message.text

                                for key, value in cmd['buttons'].items():
                                    if user_response == value:
                                        if key == '0':
                                            button_number0 = key
                                            follow_up_replies = cmd.get('follow_up_replies', {})
                                            bot_reply0 = follow_up_replies.get(button_number0,
                                                                                   "Sorry, I couldn't process your response.")
                                            await update.message.reply_text(bot_reply0)

                                            user_rebound_reply = update.message.text

                                            if user_rebound_reply:
                                                bot_final_reply = cmd.get(text=cmd['reply'])
                                            await update.message.reply_text(bot_final_reply)

                                            user_response = context.user_data.get('response')
                                        cursor.execute(
                                            "INSERT INTO command_logs (timestamp, command, reason, additional_infos) VALUES (?, ?, ?)",
                                            (current_time, user_command, user_response, user_rebound_reply))
                                        conn.commit()

                                    else:
                                        button_number = key
                                        follow_up_replies = cmd.get('follow_up_replies', {})
                                        bot_reply = follow_up_replies.get(button_number,
                                                                          "Sorry, I couldn't process your response.")

                                        await update.message.reply_text(bot_reply)

                                        # Retrieve user's reply and add to database
                                        user_response = context.user_data.get('response')
                                        cursor.execute(
                                            "INSERT INTO command_logs (timestamp, command, reason) VALUES (?, ?, ?)",
                                            (current_time, user_command, user_response))
                                        conn.commit()

    await update.message.reply_text("trololol.")


    async def handle_complex_commands(update: Update, context:CallbackContext):
    # variables
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    for command_type, command_groups in commands_data['single_orders']['complex'].items():
        for command_group in command_groups:
            for command_info in command_group['commands']:
                key_complex = command_info['key']
                print(f"Executing SQL statement: {key_complex}")
                create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_complex} (timestamp TEXT, command TEXT, reason TEXT, details TEXT)"
                cursor.execute(create_complex_table)

                if user_command == key_complex:
                    for cmd in command_group['no_rebound']:
                        if cmd['key'] == user_command:
                            follow_up_question = cmd.get('follow_up_question')
                            if follow_up_question:
                                buttons = [[value for value in cmd['buttons'].values()]]
                                custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                                await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                                user_response = update.message.text

                                for key, value in cmd['buttons'].items():
                                    if user_response == value:
                                        button_number = key
                                        follow_up_replies = cmd.get('follow_up_replies', {})
                                        bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

                                        await update.message.reply_text(bot_reply)

                                    # Retrieve user's reply and add to database
                                    user_response = context.user_data.get('response')
                                    cursor.execute("INSERT INTO command_logs (timestamp, command, additional_infos) VALUES (?, ?, ?)",
                                                   (current_time, user_command, user_response))
                                    conn.commit()
                    
                    for cmd in command_group['optional_rebound']:
                        if cmd['key'] == user_command:
                            if cmd['key'] == user_command:
                                        follow_up_question = cmd.get('follow_up_question')  # Ask reason
                                        if follow_up_question:
                                            buttons = [[value for value in cmd['buttons'].values()]]
                                            custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                                            await update.message.reply_text(follow_up_question, reply_markup=custom_markup)

                                            user_response = update.message.text

                                            for key, value in cmd['buttons'].items():
                                                if user_response == value:
                                                    if key == '0':
                                                        button_number0 = key
                                                        follow_up_replies = cmd.get('follow_up_replies', {})
                                                        bot_reply0 = follow_up_replies.get(button_number0, "Sorry, I couldn't process your response.")
                                                        await update.message.reply_text(bot_reply0)

                                                        user_rebound_reply = update.message.text

                                                        if user_rebound_reply:
                                                            bot_final_reply = cmd.get(text=cmd['reply'])
                                                            await update.message.reply_text(bot_final_reply)

                                                            user_response = context.user_data.get('response')
                                                            cursor.execute(
                                                                "INSERT INTO command_logs (timestamp, command, reason, additional_infos) VALUES (?, ?, ?)",
                                                                (current_time, user_command, user_response, user_rebound_reply))
                                                            conn.commit()

                                                    else:
                                                        button_number = key
                                                        follow_up_replies = cmd.get('follow_up_replies', {})
                                                        bot_reply = follow_up_replies.get(button_number,
                                                                          "Sorry, I couldn't process your response.")

                                                        await update.message.reply_text(bot_reply)

                                                        # Retrieve user's reply and add to database
                                                        user_response = context.user_data.get('response')
                                                        cursor.execute(
                                                            "INSERT INTO command_logs (timestamp, command, reason) VALUES (?, ?, ?)",
                                                            (current_time, user_command, user_response))
                                                        conn.commit()
                    
                    await update.message.reply_text("lol")


    # user_command = context.user_data.get('user_command')
    # cmd = context.user_data.get('cmd')

    for key, value in cmd['buttons'].items():
        if user_response == value:
            button_number = key
            follow_up_replies = cmd.get('follow_up_replies', {})
            bot_reply = follow_up_replies.get(button_number, "Sorry, I couldn't process your response.")

            await update.message.reply_text(bot_reply)

            cursor.execute("INSERT INTO command_logs (timestamp, command, additional_infos) VALUES (?, ?, ?)",
                (current_time, user_command, user_response))
            conn.commit()
            return



            async def handle_complex_commands(update: Update, context: CallbackContext):
    # Extracting user command and current time
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message

    for command_group in commands_data['single_orders']['complex']['commands']:
        for command_type, commands_list in command_group.items():
            rebound_type = command_type
            for command_info in commands_list:
                key_value = command_info['key']
                if rebound_type == 'no_rebound':
                    create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, reason TEXT)"
                elif rebound_type == 'optional_rebound':
                    create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, reason TEXT, details TEXT)"
                elif rebound_type == 'compulsory_rebound':
                    if key_value == 'privatestuff':
                        create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, texture TEXT, color TEXT)"
                    elif key_value == 'stress':
                        create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, feeling TEXT, reason TEXT)"
                cursor.execute(create_complex_table)

                # Checking if the user command matches the current key_complex
                if user_command == key_value:
                    # Checking if the command belongs to 'no_rebound' group
                    if rebound_type == 'no_rebound':
                        for cmd in command_group['no_rebound']:
                            if cmd['key'] == user_command:
                                follow_up_question = cmd.get('follow_up_question')
                                if follow_up_question:
                                    buttons = [[value for value in cmd['buttons'].values()]]
                                    custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                                    await update.message.reply_text(follow_up_question, reply_markup=custom_markup)


                    # Checking if the command belongs to 'optional_rebound' group
                    elif rebound_type == 'optional_rebound':
                        for cmd in command_group['optional_rebound']:
                            if cmd['key'] == user_command:
                                follow_up_question = cmd.get('follow_up_question')  # Ask reason
                                if follow_up_question:
                                    buttons = [[value for value in cmd['buttons'].values()]]
                                    custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
                                    await update.message.reply_text(follow_up_question, reply_markup=custom_markup)


    if not command_received:
        await update.message.reply_text("Command not found.")  




        ////////////////////////////////////////////////
        import os
from typing import Final
from telegram import ReplyKeyboardMarkup
import psycopg2
from telegram import Update, Bot
from telegram.ext import Application, MessageHandler, filters, ContextTypes, CallbackContext, CallbackQueryHandler
import json
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()
# Private infos
TOKEN = os.getenv('TOKEN')
BOT_USERNAME: Final = os.getenv('Bot')
my_chat_id = os.getenv('my_chat_id')

# Connection to database
conn = psycopg2.connect(
    dbname=os.getenv('PG_DBNAME'),
    user=os.getenv('PG_USER'),
    password=os.getenv('PG_PASSWORD'),
    host=os.getenv('PG_HOST'),
    port=os.getenv('PG_PORT')
)
cursor = conn.cursor()

# Load commands from JSON file
with open('telegrambot/singleorders.json') as f:
    commands_data = json.load(f)

# Only respond to messages from my chat_id
def echo(update: Update, context: CallbackContext) -> None:
    if update.message.chat_id == my_chat_id:
        update.message.reply_text(update.message.text)    

# HANDLE COMMANDS
async def handle_simple_commands(update: Update, context:CallbackContext):
    # variables
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # Create tables for each topic in json file
    for command_data in commands_data['single_orders']['simple']['commands']:
        key_simple = command_data['key']
        create_simple_table = f"CREATE TABLE IF NOT EXISTS {key_simple} (timestamp TEXT, command TEXT)"
        cursor.execute(create_simple_table)
        # print(f"Executing SQL statement: {key_simple}")  # Debug output

    # Check if the command exists in the JSON data
    for key in commands_data['single_orders']['simple'].items():
        for cmd in commands_data['single_orders']['simple']['commands']:
            key = cmd['key']
            if key == user_command:
                # Reply with the corresponding message
                await update.message.reply_text(text=cmd['reply'])
            
                # Log the command in the database
                cursor.execute(f"INSERT INTO {key} (timestamp, command) VALUES (%s, %s)", (current_time, user_command))
                conn.commit()
                return        
    await handle_complex_commands(update, context)

async def handle_follow_up_question(cmd, update):
    follow_up_question = cmd.get('follow_up_question')
    if follow_up_question:
        buttons = [[value for value in cmd['buttons'].values()]]
        custom_markup = ReplyKeyboardMarkup(buttons, one_time_keyboard=True)
        await update.message.reply_text(follow_up_question, reply_markup=custom_markup)  
async def handle_complex_commands(update: Update, context: CallbackContext):
    # Extracting user command and current time
    command_received = update.message.text
    user_command = command_received.split('/')[-1]  # Extract command from message

    for command_group in commands_data['single_orders']['complex']['commands']:
        for command_type, commands_list in command_group.items():
            rebound_type = command_type
            for command_info in commands_list:
                key_value = command_info['key']
                if rebound_type == 'no_rebound':
                    create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, reason TEXT)"
                elif rebound_type == 'optional_rebound':
                    create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, reason TEXT, details TEXT)"
                elif rebound_type == 'compulsory_rebound':
                    if key_value == 'privatestuff':
                        create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, texture TEXT, color TEXT)"
                    elif key_value == 'stress':
                        create_complex_table = f"CREATE TABLE IF NOT EXISTS {key_value} (timestamp TEXT, command TEXT, feeling TEXT, reason TEXT)"
                cursor.execute(create_complex_table)

                # Checking if the user command matches the current key_complex
                if user_command == key_value:
                    for cmd in command_group.get(rebound_type, []):
                        if cmd['key'] == user_command:
                            await handle_follow_up_question(cmd, update)
                            return

    if not command_received:
        await update.message.reply_text("Command not found.")  

async def handle_complex_responses(update: Update, context: CallbackContext):
    user_response = update.message.text
    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    for command_info in commands_data['single_orders']['complex']['commands']:
        for command_group in command_info.values():
            for command in command_group:
                key = command['key']
                buttons = command.get('buttons', {})
                follow_up_replies = command.get('follow_up_replies', {})
                # reply = command.get('reply', "Noted !")  # Default reply if no follow-up is found
                # Check if the user's response matches any button value
                for button_key, button_value in buttons.items():
                    if user_response == button_value:
                        # Retrieve the corresponding follow-up reply based on the button key
                        follow_up_reply = follow_up_replies.get(button_key, "Noted !")
                        await update.message.reply_text(follow_up_reply)

                        # Log the command in the database
                        cursor.execute(f"INSERT INTO {key} (timestamp, command, reason, details) VALUES (%s, %s, %s, %s)",
                                       (current_time, key, user_response, None))
                        conn.commit()
                        return

                # If no match is found, reply with the default reply
                # await update.message.reply_text(reply)

    # If the user's response doesn't match any command, reply with a generic message
    await update.message.reply_text("Sorry, I couldn't process your response.")

#  Handle unknown messages:
def handle_response(text:str) -> str:
    return 'I am sorry, I do not understand.'
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message_type: str = update.message.chat.type
    text: str = update.message.text

    print(f'User ({update.message.chat.id}) in {message_type}: "{text}"')

    if message_type == 'group':
        if BOT_USERNAME in text:
            new_text: str = text.replace(BOT_USERNAME, '').strip()
            response: str = handle_response(new_text)
        else:
            return
    else:
        response: str = handle_response(text)
    

    print('Bot', response)
    await update.message.reply_text(response)
async def error(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f'Update {update} caused error {context.error}')
if __name__ == '__main__':
    print('Starting bot...')
    app = Application.builder().token(TOKEN).build()

    # Commands
    # Simple command handler
    simple_command_handler = MessageHandler(filters.COMMAND, handle_simple_commands)
    app.add_handler(simple_command_handler)

    # Complex command handler
    complex_command_handler = MessageHandler(filters.COMMAND, handle_complex_commands)
    app.add_handler(complex_command_handler)

    complex_response_handler = MessageHandler(filters.TEXT & ~filters.COMMAND, handle_complex_responses)
    app.add_handler(complex_response_handler)

    # Messages
    app.add_handler(MessageHandler(filters.TEXT, handle_message))
    # Errors
    app.add_error_handler(error)

    #Polls the bot
    print('Polling...')
    app.run_polling(poll_interval=3)

